


<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">input</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello, world!</td>
</tr>
<tr>
<td>You can do a lot with Pixeltable UDFs.</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">input</th>
<th data-quarto-table-cell-role="th">longest_word</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello, world!</td>
<td>Hello,</td>
</tr>
<tr>
<td>You can do a lot with Pixeltable UDFs.</td>
<td>Pixeltable</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">input</th>
<th data-quarto-table-cell-role="th">longest_word</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello, world!</td>
<td>Hello,</td>
</tr>
<tr>
<td>You can do a lot with Pixeltable UDFs.</td>
<td>Pixeltable</td>
</tr>
<tr>
<td>Pixeltable updates tables incrementally.</td>
<td>incrementally.</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">input</th>
<th data-quarto-table-cell-role="th">longest_word</th>
<th data-quarto-table-cell-role="th">longest_word_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello, world!</td>
<td>Hello,</td>
<td>Hello</td>
</tr>
<tr>
<td>You can do a lot with Pixeltable UDFs.</td>
<td>Pixeltable</td>
<td>Pixeltable</td>
</tr>
<tr>
<td>Pixeltable updates tables incrementally.</td>
<td>incrementally.</td>
<td>incrementally</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">input</th>
<th data-quarto-table-cell-role="th">longest_word</th>
<th data-quarto-table-cell-role="th">longest_word_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello, world!</td>
<td>Hello,</td>
<td>Hello</td>
</tr>
<tr>
<td>You can do a lot with Pixeltable UDFs.</td>
<td>Pixeltable</td>
<td>Pixeltable</td>
</tr>
<tr>
<td>Pixeltable updates tables incrementally.</td>
<td>incrementally.</td>
<td>incrementally</td>
</tr>
<tr>
<td>Let's check that it still works.</td>
<td>works.</td>
<td>check</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">input</th>
<th data-quarto-table-cell-role="th">longest_word</th>
<th data-quarto-table-cell-role="th">longest_word_2</th>
<th data-quarto-table-cell-role="th">longest_word_3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello, world!</td>
<td>Hello,</td>
<td>Hello</td>
<td>Hello</td>
</tr>
<tr>
<td>You can do a lot with Pixeltable UDFs.</td>
<td>Pixeltable</td>
<td>Pixeltable</td>
<td>Pixeltable</td>
</tr>
<tr>
<td>Pixeltable updates tables incrementally.</td>
<td>incrementally.</td>
<td>incrementally</td>
<td>incrementally</td>
</tr>
<tr>
<td>Let's check that it still works.</td>
<td>works.</td>
<td>check</td>
<td>Let's</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">input</th>
<th data-quarto-table-cell-role="th">longest_word</th>
<th data-quarto-table-cell-role="th">longest_word_2</th>
<th data-quarto-table-cell-role="th">longest_word_3</th>
<th data-quarto-table-cell-role="th">longest_word_3_batched</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello, world!</td>
<td>Hello,</td>
<td>Hello</td>
<td>Hello</td>
<td>Hello</td>
</tr>
<tr>
<td>You can do a lot with Pixeltable UDFs.</td>
<td>Pixeltable</td>
<td>Pixeltable</td>
<td>Pixeltable</td>
<td>Pixeltable</td>
</tr>
<tr>
<td>Pixeltable updates tables incrementally.</td>
<td>incrementally.</td>
<td>incrementally</td>
<td>incrementally</td>
<td>incrementally</td>
</tr>
<tr>
<td>Let's check that it still works.</td>
<td>works.</td>
<td>check</td>
<td>Let's</td>
<td>Let's</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">sum</th>
</tr>
</thead>
<tbody>
<tr>
<td>1225</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">col_0</th>
<th data-quarto-table-cell-role="th">sum</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>45</td>
</tr>
<tr>
<td>1</td>
<td>145</td>
</tr>
<tr>
<td>2</td>
<td>245</td>
</tr>
<tr>
<td>3</td>
<td>345</td>
</tr>
<tr>
<td>4</td>
<td>445</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">sum_of_squares</th>
</tr>
</thead>
<tbody>
<tr>
<td>40425</td>
</tr>
</tbody>
</table>
`,`
<table className="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style={{'text-align: right;'}}>
<th data-quarto-table-cell-role="th">col_0</th>
<th data-quarto-table-cell-role="th">sum_of_squares</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>285</td>
</tr>
<tr>
<td>1</td>
<td>2185</td>
</tr>
<tr>
<td>2</td>
<td>6085</td>
</tr>
<tr>
<td>3</td>
<td>11985</td>
</tr>
<tr>
<td>4</td>
<td>19885</td>
</tr>
</tbody>
</table>
`];

[![Kaggle](https://kaggle.com/static/images/open-in-kaggle.svg)](https://kaggle.com/kernels/welcome?src=https://github.com/pixeltable/pixeltable/blob/release/docs/notebooks/feature-guides/udfs-in-pixeltable.ipynb)  
[![Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/pixeltable/pixeltable/blob/release/docs/notebooks/feature-guides/udfs-in-pixeltable.ipynb)

# UDFs in Pixeltable

Pixeltable comes with a library of built-in functions and integrations,
but sooner or later, you’ll want to introduce some customized logic into
your workflow. This is where Pixeltable’s rich UDF (User-Defined
Function) capability comes in. Pixeltable UDFs let you write code in
Python, then directly insert your custom logic into Pixeltable
expressions and computed columns. In this how-to guide, we’ll show how
to define UDFs, extend their capabilities, and use them in computed
columns.

To start, we’ll install the necessary dependencies, create a Pixeltable
directory and table to experiment with, and add some sample data.


```python
%pip install -qU pixeltable
```


```python

computed columns; Pixeltable will orchestrate its execution across all
the input data.

For our first working example, let’s do something slightly more
interesting: write a function to extract the longest word from a
sentence. (If there are ties for the longest word, we choose the first
word among those ties.) In Python, that might look something like this:


```python

The `longest_word` Python function isn’t a Pixeltable UDF (yet); it
operates on individual strings, not columns of strings. Adding the
decorator turns it into a UDF:


```python
@pxt.udf
def longest_word(sentence: str, strip_punctuation: bool = False) -> str:
    words = sentence.split()
    if strip_punctuation:  # Remove non-alphanumeric characters from each word
        words = [''.join(filter(str.isalnum, word)) for word in words]
    i = np.argmax([len(word) for word in words])
    return words[i]
```

Now we can use it to create a computed column. Pixeltable orchestrates
the computation like it does with any other function, applying the UDF
in turn to each existing row of the table, then updating incrementally
each time a new row is added.


```python
t.add_computed_column(longest_word=longest_word(t.input))
t.show()
```

``` text
Computing cells: 100%|███████████████████████████████████████████| 2/2 [00:00<00:00, 138.28 cells/s]
Added 2 column values with 0 errors.
```

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[1] }} />


```python
t.insert(input='Pixeltable updates tables incrementally.')
t.show()
```

``` text
Computing cells:   0%|                                                    | 0/3 [00:00<?, ? cells/s]
Inserting rows into `strings`: 1 rows [00:00, 255.24 rows/s]
Computing cells: 100%|███████████████████████████████████████████| 3/3 [00:00<00:00, 364.69 cells/s]
Inserted 1 row with 0 errors.
```

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[2] }} />

Oops, those trailing punctuation marks are kind of annoying. Let’s add
another column, this time using the handy `strip_punctuation` parameter
from our UDF. (We could alternatively drop the first column before
adding the new one, but for purposes of this tutorial it’s convenient to
see how Pixeltable executes both variants side-by-side.) Note how
*columns* such as `t.input` and *constants* such as `True` can be freely
intermixed as arguments to the UDF.


```python
t.add_computed_column(
    longest_word_2=longest_word(t.input, strip_punctuation=True)
)
t.show()
```

``` text
Computing cells: 100%|███████████████████████████████████████████| 3/3 [00:00<00:00, 252.91 cells/s]
Added 3 column values with 0 errors.
```

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[3] }} />

## Types in UDFs

You might have noticed that the `longest_word` UDF has *type hints* in
its signature.


```python
def longest_word(sentence: str, strip_punctuation: bool = False) -> str: ...
```

The `sentence` parameter, `strip_punctuation` parameter, and return
value all have explicit types (`str`, `bool`, and `str` respectively).
In general Python code, type hints are usually optional. But Pixeltable
is a database system: *everything* in Pixeltable must have a type. And
since Pixeltable is also an orchestrator - meaning it sets up workflows
and computed columns *before* executing them - these types need to be
known in advance. That’s the reasoning behind a fundamental principle of
Pixeltable UDFs: - Type hints are *required*.

You can turn almost any Python function into a Pixeltable UDF, provided
that it has type hints, and provided that Pixeltable supports the types
that it uses. The most familiar types that you’ll use in UDFs are: -
`int` - `float` - `str` - `list` (can optionally be parameterized, e.g.,
`list[str]`) - `dict` (can optionally be parameterized, e.g.,
`dict[str, int]`) - `PIL.Image.Image`

In addition to these standard Python types, Pixeltable also recognizes
various kinds of arrays, audio and video media, and documents.

## Local and Module UDFs

The `longest_word` UDF that we defined above is a *local* UDF: it was
defined directly in our notebook, rather than in a module that we

execution; changes to local UDFs will only affect *new columns* that are
defined using the new version of the UDF.

## Batching

Pixeltable provides several ways to optimize UDFs for better
performance. One of the most common is *batching*, which is particularly

several rows at a time; the specific number is user-configurable. As an
example, let’s modify our `longest_word` UDF to take a batched
parameter. Here’s what it looks like:


```python
from pixeltable.func import Batch

@pxt.udf(batch_size="1"6)
def longest_word(sentences: Batch[str], strip_punctuation: bool = False) -> Batch[str]:
    results = []
    for sentence in sentences:
        words = sentence.split()
        if strip_punctuation:
            words = [
                word if word[-1].isalnum() else word[:-1]
                for word in words
            ]
        i = np.argmax([len(word) for word in words])
        results.append(words[i])
    return results
```

There are several changes: - The parameter `batch_size="1"6` has been
added to the `@pxt.udf` decorator, specifying the batch size; - The
`sentences` parameter has changed from `str` to `Batch[str]`; - The
return type has also changed from `str` to `Batch[str]`; and - Instead
of processing a single sentence, the UDF is processing a `Batch` of
sentences and returning the result `Batch`.

What exactly is a `Batch[str]`? Functionally, it’s simply a `list[str]`,
and you can use it exactly like a `list[str]` in any Python code. The
only difference is in the type hint; a type hint of `Batch[str]` tells
Pixeltable, “My data consists of individual strings that I want you to
process in batches”. Conversely, a type hint of `list[str]` would mean,
“My data consists of *lists* of strings that I want you to process one
at a time”.

Notice that the `strip_punctuation` parameter is *not* wrapped in a
`Batch` type. This because `strip_punctuation` controls the behavior of
the UDF, rather than being part of the input data. When we use the
batched `longest_word` UDF, the `strip_punctuation` parameter will
always be a constant, not a column.

Let’s put the new, batched UDF to work.


```python
t.add_computed_column(
    longest_word_3_batched=longest_word(t.input, strip_punctuation=True)
)
t.show()
```

``` text
Computing cells: 100%|███████████████████████████████████████████| 4/4 [00:00<00:00, 353.90 cells/s]
Added 4 column values with 0 errors.
```

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[6] }} />

As expected, the output of the `longest_word_3_batched` column is
identical to the `longest_word_3` column. Under the covers, though,
Pixeltable is orchestrating execution in batches of 16. That probably
won’t have much performance impact on our toy example, but for GPU-bound
computations such as text or image embeddings, it can make a substantial
difference.

## UDAs (Aggregate UDFs)

Ordinary UDFs are always one-to-one on rows: each row of input generates
one UDF output value. Functions that aggregate data, conversely, are
many-to-one, and in Pixeltable they are represented by a related
abstraction, the UDA (<i>U</i>ser-<i>D</i>efined <i>A</i>ggregate).
Pixeltable has a number of built-in UDAs; if you’ve worked through the
Fundamentals tutorial, you’ll have already encountered a few of them,
such as `sum` and `count`. In this section, we’ll show how to define
your own custom UDAs. For demonstration purposes, let’s start by
creating a table containing all the integers from 0 to 49.


```python

-   `__init__()` - initializes the aggregator; can be used to
    parameterize aggregator behavior
-   `update()` - updates the internal state of the aggregator with a new
    value
-   `value()` - retrieves the current value held by the aggregator

In our example, the class will have a single member `cur_sum`, which
holds a running total of the squares of all the values we’ve seen.


```python
@pxt.uda
class sum_of_squares(pxt.Aggregator):
    def __init__(self):
        # No data yet; initialize `cur_sum` to 0
        self.cur_sum = 0

    def update(self, val: int) -> None:
        # Update the value of `cur_sum` with the new datapoint
        self.cur_sum += val * val

    def value(self) -> int:
        # Retrieve the current value of `cur_sum`
        return self.cur_sum
```


```python
t.select(sum_of_squares(t.val)).collect()
```

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[9] }} />


```python
t.group_by(t.val // 10).order_by(t.val // 10).select(
    t.val // 10, sum_of_squares(t.val)
).collect()
```

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[10] }} />
